#include <iostream>
#include <algorithm> // For min() function
#include "InGameState.h"
#include "MainMenuState.h"
#include "LoadGameState.h"
#include "GameEngine.h"
#include "game/SaveSystem.h"
#include <optional>
#include <SFML/Window/Event.hpp>

using namespace std;

// Helper to convert std::string (UTF-8) to sf::String
sf::String to_sf_string_ingame(const std::string& s) {
    return sf::String::fromUtf8(s.begin(), s.end());
}

InGameState::InGameState(GameEngine& game)
    : GameState(game),
      dialogueVisitor(game.getWindow()),
      currentDialogueNode(nullptr),
      currentNodeId("root"),
      showMenu(false),
      hoveredButton(-1) {
    cout << "InGameState constructor start" << endl;

    // Load UI font
    if (!uiFont.openFromFile("assets/arial.ttf")) {
        cerr << "Error loading UI font" << endl;
    }

    // Create text objects with font
    saveButtonText = new sf::Text(uiFont);
    loadButtonText = new sf::Text(uiFont);
    exitButtonText = new sf::Text(uiFont);
    backButtonText = new sf::Text(uiFont);

    // Initialize UI buttons (positioned at top right)
    sf::Vector2u windowSize = game.getWindow().getSize();
    float buttonWidth = 80.0f;
    float buttonHeight = 35.0f;
    float buttonMargin = 10.0f;
    float topMargin = 10.0f;

    // Back button (leftmost) - Uses Stack for undo
    backButton.setSize({buttonWidth, buttonHeight});
    backButton.setPosition({windowSize.x - (buttonWidth + buttonMargin) * 4, topMargin});
    backButton.setFillColor(sf::Color(100, 80, 140, 200));
    backButton.setOutlineColor(sf::Color(150, 120, 200));
    backButton.setOutlineThickness(2);

    backButtonText->setString(to_sf_string_ingame("Back"));
    backButtonText->setCharacterSize(18);
    backButtonText->setFillColor(sf::Color::White);
    backButtonText->setPosition({backButton.getPosition().x + 20, backButton.getPosition().y + 7});

    // Save button
    saveButton.setSize({buttonWidth, buttonHeight});
    saveButton.setPosition({windowSize.x - (buttonWidth + buttonMargin) * 3, topMargin});
    saveButton.setFillColor(sf::Color(60, 100, 140, 200));
    saveButton.setOutlineColor(sf::Color(100, 150, 200));
    saveButton.setOutlineThickness(2);

    saveButtonText->setString(to_sf_string_ingame("Save"));
    saveButtonText->setCharacterSize(18);
    saveButtonText->setFillColor(sf::Color::White);
    saveButtonText->setPosition({saveButton.getPosition().x + 20, saveButton.getPosition().y + 7});

    // Load button
    loadButton.setSize({buttonWidth, buttonHeight});
    loadButton.setPosition({windowSize.x - (buttonWidth + buttonMargin) * 2, topMargin});
    loadButton.setFillColor(sf::Color(60, 100, 140, 200));
    loadButton.setOutlineColor(sf::Color(100, 150, 200));
    loadButton.setOutlineThickness(2);

    loadButtonText->setString(to_sf_string_ingame("Load"));
    loadButtonText->setCharacterSize(18);
    loadButtonText->setFillColor(sf::Color::White);
    loadButtonText->setPosition({loadButton.getPosition().x + 20, loadButton.getPosition().y + 7});

    // Exit button
    exitButton.setSize({buttonWidth, buttonHeight});
    exitButton.setPosition({windowSize.x - (buttonWidth + buttonMargin), topMargin});
    exitButton.setFillColor(sf::Color(140, 60, 60, 200));
    exitButton.setOutlineColor(sf::Color(200, 100, 100));
    exitButton.setOutlineThickness(2);

    exitButtonText->setString(to_sf_string_ingame("Exit"));
    exitButtonText->setCharacterSize(18);
    exitButtonText->setFillColor(sf::Color::White);
    exitButtonText->setPosition({exitButton.getPosition().x + 23, exitButton.getPosition().y + 7});

    // Apply text speed from settings
    dialogueVisitor.setTextSpeed(game.getSettings().getTextSpeedMultiplier());
    dialogueVisitor.setPlayer(&game.getPlayer());

    auto* dialogueGraph = game.getDialogueGraph();
    if (dialogueGraph) {
        dialogueGraph->setDialogueStartCallback([this](NTree<Dialogue, MAX_CHOICES>* node) {
            cout << "Dialogue start callback" << endl;
            if (node && !node->isEmpty()) {
                currentDialogueNode = node;
                currentDialogueNode->getKey().accept(dialogueVisitor);
            } else {
                currentDialogueNode = nullptr;
            }
        });

        auto* rootNode = dialogueGraph->buildTree();
        cout << "Tree built" << endl;
        if (rootNode) {
            game.getPlayer().displayStatus();
            if (rootNode && !rootNode->isEmpty()) {
                currentDialogueNode = rootNode;
                cout << "Accepting visitor" << endl;
                currentDialogueNode->getKey().accept(dialogueVisitor);
                cout << "Visitor accepted" << endl;
            } else {
                currentDialogueNode = nullptr;
            }
        } else {
            cerr << "Failed to build dialogue tree!" << endl;
        }
    }
    cout << "InGameState constructor end" << endl;
}

InGameState::InGameState(GameEngine& game, const string& startNodeId)
    : GameState(game),
      dialogueVisitor(game.getWindow()),
      currentDialogueNode(nullptr),
      currentNodeId(startNodeId),
      showMenu(false),
      hoveredButton(-1) {

    if (!uiFont.openFromFile("assets/arial.ttf")) {
        cerr << "Error loading UI font" << endl;
    }

    // Create text objects with font
    saveButtonText = new sf::Text(uiFont);
    loadButtonText = new sf::Text(uiFont);
    exitButtonText = new sf::Text(uiFont);
    backButtonText = new sf::Text(uiFont);

    sf::Vector2u windowSize = game.getWindow().getSize();
    float buttonWidth = 80.0f;
    float buttonHeight = 35.0f;
    float buttonMargin = 10.0f;
    float topMargin = 10.0f;

    // Back button (leftmost) - Uses Stack for undo
    backButton.setSize({buttonWidth, buttonHeight});
    backButton.setPosition({windowSize.x - (buttonWidth + buttonMargin) * 4, topMargin});
    backButton.setFillColor(sf::Color(100, 80, 140, 200));
    backButton.setOutlineColor(sf::Color(150, 120, 200));
    backButton.setOutlineThickness(2);
    backButtonText->setString(to_sf_string_ingame("Back"));
    backButtonText->setCharacterSize(18);
    backButtonText->setFillColor(sf::Color::White);
    backButtonText->setPosition({backButton.getPosition().x + 20, backButton.getPosition().y + 7});

    saveButton.setSize({buttonWidth, buttonHeight});
    saveButton.setPosition({windowSize.x - (buttonWidth + buttonMargin) * 3, topMargin});
    saveButton.setFillColor(sf::Color(60, 100, 140, 200));
    saveButton.setOutlineColor(sf::Color(100, 150, 200));
    saveButton.setOutlineThickness(2);
    saveButtonText->setString(to_sf_string_ingame("Save"));
    saveButtonText->setCharacterSize(18);
    saveButtonText->setFillColor(sf::Color::White);
    saveButtonText->setPosition({saveButton.getPosition().x + 20, saveButton.getPosition().y + 7});

    loadButton.setSize({buttonWidth, buttonHeight});
    loadButton.setPosition({windowSize.x - (buttonWidth + buttonMargin) * 2, topMargin});
    loadButton.setFillColor(sf::Color(60, 100, 140, 200));
    loadButton.setOutlineColor(sf::Color(100, 150, 200));
    loadButton.setOutlineThickness(2);
    loadButtonText->setString(to_sf_string_ingame("Load"));
    loadButtonText->setCharacterSize(18);
    loadButtonText->setFillColor(sf::Color::White);
    loadButtonText->setPosition({loadButton.getPosition().x + 20, loadButton.getPosition().y + 7});

    exitButton.setSize({buttonWidth, buttonHeight});
    exitButton.setPosition({windowSize.x - (buttonWidth + buttonMargin), topMargin});
    exitButton.setFillColor(sf::Color(140, 60, 60, 200));
    exitButton.setOutlineColor(sf::Color(200, 100, 100));
    exitButton.setOutlineThickness(2);
    exitButtonText->setString(to_sf_string_ingame("Exit"));
    exitButtonText->setCharacterSize(18);
    exitButtonText->setFillColor(sf::Color::White);
    exitButtonText->setPosition({exitButton.getPosition().x + 23, exitButton.getPosition().y + 7});

    dialogueVisitor.setTextSpeed(game.getSettings().getTextSpeedMultiplier());
    dialogueVisitor.setPlayer(&game.getPlayer());

    auto* dialogueGraph = game.getDialogueGraph();
    if (dialogueGraph) {
        dialogueGraph->setDialogueStartCallback([this](NTree<Dialogue, MAX_CHOICES>* node) {
            if (node && !node->isEmpty()) {
                currentDialogueNode = node;
                currentDialogueNode->getKey().accept(dialogueVisitor);
            } else {
                currentDialogueNode = nullptr;
            }
        });

        auto* rootNode = dialogueGraph->buildTree();
        if (rootNode) {
            game.getPlayer().displayStatus();
            if (rootNode && !rootNode->isEmpty()) {
                currentDialogueNode = rootNode;
                currentDialogueNode->getKey().accept(dialogueVisitor);
            } else {
                currentDialogueNode = nullptr;
            }
        } else {
            cerr << "Failed to build dialogue tree!" << endl;
        }
    }
}

InGameState::~InGameState() {
    // Clean up dynamically allocated text objects
    delete saveButtonText;
    delete loadButtonText;
    delete exitButtonText;
    delete backButtonText;
}

void InGameState::handleEvent(const sf::Event& event) {
    // Handle events specific to the in-game state
    if (event.type == sf::Event::KeyPressed) {
        if (event.key.code == sf::Keyboard::Escape) {
            // Pause the game and show the menu
            showMenu = true;
        } else if (event.key.code == sf::Keyboard::Space) {
            // TODO: Trigger dialogue advancement or interaction
        }
    } else if (event.type == sf::Event::MouseButtonPressed) {
        if (event.mouseButton.button == sf::Mouse::Left) {
            // Handle button clicks
            if (showMenu) {
                // Check if any menu button is clicked
                if (saveButton.getGlobalBounds().contains(event.mouseButton.x, event.mouseButton.y)) {
                    // TODO: Implement save functionality
                    cout << "Save button clicked" << endl;
                } else if (loadButton.getGlobalBounds().contains(event.mouseButton.x, event.mouseButton.y)) {
                    // TODO: Implement load functionality
                    cout << "Load button clicked" << endl;
                } else if (exitButton.getGlobalBounds().contains(event.mouseButton.x, event.mouseButton.y)) {
                    // Exit the game
                    game.quit();
                } else if (backButton.getGlobalBounds().contains(event.mouseButton.x, event.mouseButton.y)) {
                    // Go back to the previous state
                    game.popState();
                }
            } else {
                // TODO: Handle in-game clicks (e.g., interacting with objects)
            }
        }
    }
}

void InGameState::update(sf::Time dt) {
    // Update game logic for the in-game state

    if (currentDialogueNode) {
        // Update dialogue dynamics if a dialogue node is active
        currentDialogueNode->update(dt);
    }

    // TODO: Add more update logic as needed
}

void InGameState::render(sf::RenderTarget& target, sf::RenderStates states) const {
    // Render the in-game elements

    // Example: Clear the target with a specific color
    target.clear(sf::Color(50, 50, 50));

    // Render dialogue or game elements
    if (currentDialogueNode) {
        currentDialogueNode->getKey().render(target, states);
    }

    // Render UI buttons
    target.draw(saveButton, states);
    target.draw(loadButton, states);
    target.draw(exitButton, states);
    target.draw(backButton, states);

    // Draw button texts
    target.draw(*saveButtonText, states);
    target.draw(*loadButtonText, states);
    target.draw(*exitButtonText, states);
    target.draw(*backButtonText, states);

    // TODO: Render other in-game elements
}

void InGameState::pause() {
    // Pause the game state (e.g., when the menu is opened)
    showMenu = true;
}

void InGameState::resume() {
    // Resume the game state (e.g., when the menu is closed)
    showMenu = false;
}

void InGameState::setCurrentNodeId(const string& nodeId) {
    currentNodeId = nodeId;
    // TODO: Update the dialogue system to jump to the specific node
}

const string& InGameState::getCurrentNodeId() const {
    return currentNodeId;
}

void InGameState::onEnter() {
    // Code to execute when entering this game state
    cout << "Entered InGameState" << endl;
}

void InGameState::onExit() {
    // Code to execute when exiting this game state
    cout << "Exited InGameState" << endl;
}

bool InGameState::isMenuVisible() const {
    return showMenu;
}

void InGameState::toggleMenuVisibility() {
    showMenu = !showMenu;
}
